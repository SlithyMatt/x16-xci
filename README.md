# XCI: eXtremely Compact Interpreter
An adventure game engine for the Commander X16

## Overview
XCI is an adventure game engine designed to be as compact as
possible while still creating a rich experience, featuring a
point-and-click interface, animated sprites, and detailed backgrounds.
This is being designed specifically for the Commander X16
retrocomputer, which has just over 37kB of base RAM, 512kB of
extended RAM split into 8kB banks, and 128kB of VRAM. It uses a
65C02 CPU, standard PS/2 mouse and keyboard, and an FPGA-based
video adapter (VERA) that can output 256 colors at a 640x480 resolution.
Because of the memory restrictions, XCI will be using 16 colors
per element at a 320x240 resolution. The X16 allows elements
to have a palette offset to choose which "row" of 16 colors from
the 256-color palette will be used.

The elements of the game consist of three independent layers:
* 320x200 Bitmap backgound, placed 8 pixels from the top of the screen, then end 32 pixels from the bottom. The entire bitmap
will comprise of only 16 colors, taken from a palette offset.
* 40x30 map of 8x8 tiles. Each tile can have 16 colors, but also
its own palette offset. The tiles provide a menu at the top of the
screen, text display and controls at the bottom. Tiles may also
act as static overlays on top of the background. Up to 720 unique
tiles can be defined.
* 128 individual 16x16 sprites, including a dynamic mouse cursor.
Each sprite can have 16 colors, from its own palette offset. Up to 512 unique sprite frames can be defined. All sprites except for the mouse cursor are confined to the bitmap area, and support collision
with other sprites and tiles. The mouse cursor is context-sensitive,
changing its frame based on its position and game state to indicate
the type of action that will happen when the mouse button is clicked.

## Memory Map
Main RAM ($0801-$9EFF): XCI engine code, top-level game data

Banked RAM ($A000-$BFFF): 6 banks per level, up to 10 levels per currently loaded zone.
* Bank 0: Kernal Use
* Bank 1: Zone level 0 configuration data
* Banks 2-5: Zone level 0 background bitmap
* Bank 6: Zone level 0 music and sound effects
* Bank 7: Zone level 1 configuration data

...
* Bank 60: Zone level 9 music and sound effects

When transit from a level leads to a different zone, the new
zone is loaded to banked RAM from the file system. Up to 256
different zones can be defined.

VRAM:
* Bank 0: Bitmap ($0000-$95FF), Tile Map ($9600-$A5FF), Tiles ($A600-$FFFF)
* Bank 1: Sprites ($0000-$FFFF)

## Data Format
All game data is described in text files, starting with a main file. This file defines the top-level game data, providing references to all other source files. Its filename is the only input to the build utility (**xci.exe**). It is simply a set of key-value pairs. There are certain mandatory keys that are required for the game to be successfully built. Unrecognized keys are ignored by the build utility, as are comments, which begin with a hash (```#```) symbol. Keys have no spaces and are not case-sensitive, but values may be case-sensitive and consist of all text after the first whitespace after the key up to the end of the line or the start of a comment. New lines can be part of a value by using the escape code ```\n```. A value can contain a hash character by escaping it with a backslash (i.e. ```\#```). And if a value contains a backslash character, that can be escaped with a double backslash (```\\```).

### Main File
The following is an example of a main file, showing all required keys.

```
# This is a comment
title My Game
author John Doe
palette mygame_pal.hex
tiles mygame_tiles.hex
sprites mygame_sprites.hex
menu mygame_menu.xci
title_screen mygame_start.xci
init_cursor 0 # sprite frame index
zone mygame_zone0.xci # the first zone defined will be loaded first,
                      # with its first level the start of the game
zone mygame_zone1.xci
zone mygame_zone2.xci
```

Let's say this file is named **mygame.xci**. The game can be built by passing it to the build utility, as follows:

```
$ /path/to/xci.exe mygame.xci
```

If it finishes without errors, the game is built! Let's assume that zone 0 has 2 levels, zone 1 has 3 levels, and zone 2 a full 10 levels. The following binaries will be generated:

* **MAIN.BIN** - This is the compiled version of **mygame.xci**. This will be loaded into base RAM by the XCI program (**XCI.PRG**) at run time. This and all binaries generated by the build utility (in addition to **XCI.PRG**) need to be loaded into the X16 file system to run the game. It will contain information from **mygame.xci** and other files specified by the main file keys.
* **PAL.BIN** - This is the binary version of **mygame_pal.hex**, which contains the initial palette for the game, as specified by the **palette** key. It will be loaded by the XCI program into VRAM (F:1000) prior to displaying the title screen. Note that the palette beyond index 15 will be modified as different parts of the game are loaded, including the title screen.
* **TILES.BIN** - This is the binary version of **mygame_tiles.hex**, which contains the tile set for the game, as specified by the **tiles** key. It will be loaded by the XCI program into VRAM (0:A600) prior to displaying the title screen.
* **SPRITES.BIN** - This is the binary version of **mygame_sprites.hex**, which contains the sprite frames for the game, as specified by the **sprites** key. It will be loaded by the XCI program into VRAM (1:0000) prior to displaying the title screen.
* **TITLE.BIN** - This is the background bitmap for the title screen, specified by the contents of **mygame_start.xci**, which will be explained later. It will be loaded into VRAM (0:0000) once the palette, tiles and sprites are all loaded. Unlike the background bitmaps of the game levels, this bitmap can take up the full screen (320x240). This will remain in VRAM and on screen until the player starts a new game or loads a saved game. It is never stored in base or banked RAM.
* **Z0.L0.1.BIN** - This is the configuration data for level 0 of zone 0. This is the first level that will be loaded after starting a new game. It is defined by the contents of **mygame_zone0.xci**, as specified by the first instance of the **zone** key. It will be loaded into bank 1 of banked RAM whenever the game enters level 0 (as it does when starting a new game, but a saved game may have also left off in level 0).
* **Z0.L0.2.BIN** - This is the background bitmap for level 0 of zone 0, specified by the contents of **mygame_zone0.xci**, which will be explained later. It will be loaded into banks 2-5 of banked RAM whenever the game enters zone 0, and into VRAM when the game enters level 0. Because of the in-game screen layout, this bitmap will start 8 pixel9s from the top, and therefore starting at VRAM address 0:0500. From 0:0000 to 0:04FF will be zero-filled, as it lies behind the menu bar. From 0:7D00 to 0:95FF will be zero-filled, as it lies behind the text field/toolbar.
* **Z0.L0.6.BIN** - The music and sound effects for level 0 of zone 0. The length of the music and addresses for each sound effect are defined in the level configuration data. This file will be loaded into bank 6 when the game enters zone 0. They data will be played directly from banked RAM when the game enters level 0.
* **Z0.L1.7.BIN** - This is the configuration data for level 1 of zone 0. It will be loaded to bank 7 when the game enters zone 0.
* **Z0.L1.8.BIN** - This file contains the background bitmap for level 1 of zone 0. It will be loaded into banks 8-11 when the game enters zone 0, and into VRAM starting at 0:0500 when the game enters level 1.
* **Z0.L1.12.BIN** - The music and sound effects for level 1 of zone 0. It will be loaded to bank 12 when the game enters zone 0. It is also the last file to be loaded into banked RAM for zone 0, as it only contains two levels. When starting a new game, or loading a game that left off in zone 0, the rest of the files below will not be loaded from the file system at the beginning of game play.
* **Z1.L0.1.BIN, Z1.L0.2.BIN, Z1.L0.6.BIN** - All data for level 0 of zone 1. These will be loaded into banks 1-6 when the game enters zone 1.
* **Z1.L1.7.BIN, Z1.L1.8.BIN, Z1.L1.12.BIN** - All data for level 1 of zone 1. These will be loaded into banks 7-12 when the game enters zone 1.
* **Z1.L2.13.BIN, Z1.L2.14.BIN, Z1.L2.18.BIN** - All data for level 2 of zone 1. These will be loaded into banks 13-18 when the game enters zone 1. They are the last files to be loaded into banked RAM for zone 1.
* **Z2.L0.1.BIN, Z2.L0.2.BIN, Z2.L0.6.BIN** - Zone 2, level 0
* **Z2.L1.7.BIN, Z2.L1.8.BIN, Z2.L1.12.BIN** - Zone 2, level 1
* **Z2.L2.13.BIN, Z2.L2.14.BIN, Z2.L2.18.BIN** - Zone 2, level 2
* **Z2.L3.19.BIN, Z2.L3.20.BIN, Z2.L3.24.BIN** - Zone 2, level 3
* **Z2.L4.25.BIN, Z2.L4.26.BIN, Z2.L4.30.BIN** - Zone 2, level 4
* **Z2.L5.31.BIN, Z2.L5.32.BIN, Z2.L5.36.BIN** - Zone 2, level 5
* **Z2.L6.37.BIN, Z2.L6.38.BIN, Z2.L6.42.BIN** - Zone 2, level 6
* **Z2.L7.43.BIN, Z2.L7.44.BIN, Z2.L7.48.BIN** - Zone 2, level 7
* **Z2.L8.49.BIN, Z2.L8.50.BIN, Z2.L8.54.BIN** - Zone 2, level 8
* **Z2.L9.55.BIN, Z2.L9.56.BIN, Z2.L9.60.BIN** - Zone 2, level 9. These are loaded into banks 55-60, the highest RAM banks that can be populated by an XCI game, when the game enters zone 2.

Wow, that's a lot of files! But most of them are 32kB or smaller. Each zone would easily fit on a single double-density 3.5" floppy, to put it in perspective. In this case, the whole game maxes out at 870kB (and that's assuming very complicated title screen and levels, and all available sprite frames and tiles defined), which would fit on a single high-density floppy, 2 double-density 3.5" floppies, or 3 double-density 5.25" floppies. The biggest XCI game possible would be 125MB, or 87 high-density 3.5" floppies. A CD-ROM could hold at least 5 XCI games. A 2GB SD Card could hold at least 16. Of course, it is highly unlikely that even the most prolific storyteller could come up with 2550 levels for a single game, so most games should clock in at around 5MB, which means that an X16 user could play hundreds of XCI games without changing their SD card. Because of filename conflicts, each game would need to be in a separate directory.

#### Main File: Required Keys

The following are the required keys for the main file. Any keys outside of these will be ignored. If any of these are missing from the main file or have values that are formatted incorrectly, the game will fail to build. Please note that your development platform may have a case-sensitive file system (e.g. Linux, Mac), so the capitalization of filename values matters. Meanwhile all keys are not case-sensitive, but they must be spelled correctly and be immediately followed only by whitespace and then the value. This is the case for all XCI configuration files.

* **title** - Title of the game, will be printed to console when graphics data is loading. The maximum length is 255 characters, and it will be placed at the very beginning of **MAIN.BIN**.
* **author** - Author of the game, which will also be printed to the console.  The maximum length is 255 characters, and it will be placed 256 bytes into **MAIN.BIN**, after the space reserved for the title. The title and author will also be the main meta data to discriminate between different instances of **MAIN.BIN**.
* **palette** - Filename of the hex file containing the initial palette. The format of this file will be explained in the [Palette Hex File](#palette-hex-file) section. This file must be in the same directory as the main file, or the value must contain the path to the file. This applies to all filename values in XCI configuration source files.
* **tiles** - Filename of the hex file containing the tile definitions. The format of this file will be explained in the [Tiles Hex File](#tiles-hex-file) section.
* **sprites** - Filename of the hex file containing the sprite definitions. The format of this file will be explained in the [Sprites Hex File](#sprites-hex-file) section.
* **menu** - Filename of the menu file, another XCI configuration file like the main file.  The format of this file will be explained in the [Menu File](#menu-file) section.
* **title_screen** - Filename of the title screen file.  The format of this file will be explained in the [Title Screen File](#title-screen-file) section.
* **init_cursor** - Sprite frame used as the initial mouse cursor.  The sprite frames start with index zero, which is the first 16x16 bitmap defined in **SPRITES.BIN**. This value must be between 0 and the highest sprite frame index, which could be as high as 511, depending on the size of **SPRITES.BIN**.
* **zone** - This is the only key which can have more than one instance in the main file. The first instance will be for filename of the zone file that will be used for zone 0. The remaining instances will determine the index order for all zone files, from 1 up to 255. Any **zone** instances past the 256th will be ignored. The format for these files will be explained in the [Zone Files](#zone-files) section.

### Hex Files
Hex files are a human-friendly way of specifying binary data. Every four bits of data are represented by a single hexadecimal digit, represented as an ASCII character, ```0``` through ```9``` and ```A``` through ````F````, representing the binary values of 0000 through 1111, or 0 through 15 in decimal. The format of the binary data specified by hex files is determined by the X16's VERA video adapter, which is documented in the [VERA Programmer's Reference](https://github.com/commanderx16/x16-docs/blob/master/VERA%20Programmer's%20Reference.md). The binary files generated from the hex files will be loaded directly into VRAM and the contents are not verified in any way.

Like XCI configuration files, hex files can contain comments starting with ```#```, which may be at the very beginning of a line, or after a line of hex characters.  If any non-hex or non-whitespace characters appear on a line before a ```#```, the game will fail to build.  Hex files are not case sensitive at all, so upper and lowercase letters are interchangeable for ```A``` through ```F```.

Whitespace can be used however the developer sees fit, separating each byte with a space, or just having a whole block of hex characters uninterrupted. The only limitations are that each line may be no more than 1000 characters wide, and have an even number of hex characters (bytes may not be split across lines). The following is an example of a valid hex file.

```
# Header comment
12 34 56 78       # Bytes
9ABC DEF0         # Words
13579BDF 02468ACE # double words
```

To be loadable by the X16, binary files require a two-byte header, which is effectively ingored, so the binaries build from hex files will always start with two null, or zero bytes. The following table shows byte-by-byte what will be written to a binary file that would be build from the above hex file. Note that the hex files have no concept of "endianness" based on the whitespace; each 4-bit nibble will be written out in binary in the order they are read from hex characters.

| Hex | Binary | Decimal | Notes     |
|-----|--------|---------|-----------|
|   00|00000000|        0|Ignored, but required by X16|
|   00|00000000|        0|Ignored    |
|   12|00010010|       18|From line 1, this is the first actual byte that will be loaded to VRAM|
|   34|00110100|       52|           |
|   56|01010110|       86|           |
|   78|01111000|      120|           |
|   9A|10011010|      154|From line 2|
|   BC|10111100|      188|           |
|   DE|11011110|      222|           |
|   F0|11110000|      240|           |
|   13|00010011|       19|From line 3|
|   57|01010111|       87|           |
|   9B|10011011|      155|           |
|   DF|11011111|      223|           |
|   02|00000010|        2|           |
|   46|01000110|       70|           |
|   8A|10001010|      138|           |
|   CE|11001110|      206|This is the last of 16 bytes that will be loaded to VRAM|

Now, we will see what each of the hex files should contain.

#### Palette Hex File
The initial palette hex file may contain all 256 colors, but for practical purposes it only needs to define the first 16 colors of the palette.  This is in the format specified by the VERA documentation: two bytes for each color, with 4 bits for each of red, green and blue and four unused bits.  This means that a single hex character represents each color component from 0 to F (15 decimal). In binary, the two-byte field is formatted as ```bbbbgggg 0000rrrr```. So, pure white would be ```11111111 00001111``` in binary, or ```FF 0F``` in hex. So, 16 colors would be simply 64 hex characters.

The following example shows how a hex file would specify the first 16 colors of the default X16 palette.

```
# Default X16 palette, offset 0
0000 FF0F 0008 FE0A 4C0C C500 0A00 E70E 850D 4006 770F 3303 7707 F60A 8F00 BB0B
```

When VERA elements are using 16 colors (as all elements in XCI game do), the color is specified by a four-bit value, or a single hex digit, representing 0 through 15. Despite how the palette may be configured, color 0 of every palette offset is transparent, so it might as well be black, as shown above. As we can see, the next color value is white, which is color index 1. So, a bitmap where each byte is hex ```01``` would have alternating transparent and white pixels. Looking down the palette, we can see that color index 2 is a medium red, as the blue and green values are set to zero, but the red value is set to 8, which is the middle intensity between 1 and 15. Making each byte of a bitmap hex ```12``` would have alternating white and red pixels, with no transparency. We will see more concrete examples of hex-encoded bitmaps in the next two sections, which will assume the default palette.

#### Tiles Hex File
The tiles for XCI games are 8x8 pixels, with 4 bits per pixel. So, for the hex file, each hex character will represent a pixel of a tile, and 64 characters (32 bytes) are required to define one tile. XCI allows for up to 720 different tiles to be defined in this file, but at least 177 need to be defined. This is because tile indices 32 (space) through 176 (tilde) will be an ASCII character font. Included with the XCI development kit is an example tile set that defines a default character font and some other basic tiles that are needed for the menu and toolbar. But, you are completely free to redefine all of them, just remember the usage of those ASCII character tiles for the menu and text field is fixed. Also, the characters should use color 1 for their foreground and 6 for their background, just like the initial X16 BASIC screen, so that the configuration can effectively switch out those colors in other palette offsets. If colors other than those are used in ASCII tiles, they will not chage their color values from palette offset 0.

Also note that while tiles being used for the menu, text field and tool will be using palette offset zero, as defined by the palette hex file, within the levels, any tile may be used with any of the palette offsets available in the current zone. This means that tiles (and sprites!) can be used as overlays on the level bitmap to add additional color depth. Tiles can also be flipped both horizontally and vertically.

The following is an example of the beginning of a tile set. Comments describe what each tile is supposed to be.

```
# Tile 0: Solid white square
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

# Tile 1: Small red circle with white outline, transparent background
00000000
00011000
00122100
01222210
01222210
00122100
00011000
00000000

# Tile 2: White square with rounded corner. Can be flipped to round different
#         different corners of a white box
11100000
11111000
11111100
11111110
11111110
11111111
11111111
11111111

# Tile 3: Commander X16 "Butterfly"
44000044
0EE00EE0
00333300
00055000
00777700
08800880
22000022
00000000
```

Using these tiles, we can build a little tile map that defines a rounded white box with the red circle and butterfly inside. The first tile we need is the upper-left corner. Tile 2 has the corner in the upper-right corner, so it will need to be flipped horizontally. Then, we need two white squares (tile 0), and then the upper-right corner, where we can use tile 2 without any flipping. That's the entire first row, so
onto the second row, where we start with a white square for the left side, then the circle (tile 2), the butterfly (tile 3) and another white square for the right side. Finally, the last row starts with tile 2 flipped both horizontally and vertically to make the lower-left corner, two more white squares, and then finishing with tile 2 flipped vertically to make the lower-right corner.

And here's what you get: ![tile map example](example/tilebox.png)

Later on, we'll see how tiles are used to define the menu and toolbar, and how they can be added to game levels.

#### Sprites Hex File
All sprites for XCI games are 16x16 pixels, but since there are up to 128 sprites available for rendering at any time, larger sprites can be accomplished by synchronizing the movements of adjacent sprites. Each sprite can have 16 colors, and use any palette offset at any time.  Like tiles, sprites can add to the color depth of an image, with the added capability of being able to be placed at any position on screen.  The only required sprite is the mouse cursor, which must be sprite index 0. However, any sprite frame may be used for the mouse cursor, but its initial frame is determined my the **init_cursor** key in the main file.  Generally this should be a simple pointer cursor, but during game play the cursor can be context-sensitive, changing its frame based on its position and game state. Many games have a player avatar sprite, but that is not required for XCI. Sprite movements may be pre-programmed to happen once or loop through a level, or they could respond to mouse actions. Each frame of each sprite's potential movement needs to be defined, but like tiles, sprite frames can change their appearance through changing the palette offset or flipping horizontally, vertically or both.

Each sprite frame has an index, which is used to specify which frame any given sprite should be displaying according to the game configuration. Any sprite can use any of the frames, from index 0 through 511, or whatever the highest defined sprite index is in the hex file. The example below shows a very basic example of a sprite frame set. You may recognize the player avatar from [Chase Vault](https://github.com/SlithyMatt/x16-chasevault).

```
# frame 0: initial mouse cursor
f000000000000000
f100000000000000
f110000000000000
f111000000000000
f111100000000000
f111110000000000
f111111000000000
fff1100000000000
000f110000000000
000f100000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
# frame 1: player avatar standing, side
0000000977000000
0000007797700000
0000079779977000
0000077997700000
0000999776a00000
0000777aaaaa0000
000070aaaaa00000
0000000aaa000000
0000009997700000
0000095775500000
0000995775500000
00009959a5500000
0000999555000000
0000000990000000
0000000990000000
0000000bbb000000
# frame 2: player avatar walking 1, side
0000000977000000
0000007797700000
0000079779977000
0000077997700000
0000999776a00000
0000777aaaaa0000
000070aaaaa00000
0000000aaa000000
0000009997700000
0000095777500000
0000995577500000
000099595a500000
0000999555000000
0000000999000000
00000b99099b0000
000000bb0bb00000
# frame 3: player avatar walking 2, side
0000000977000000
0000007797700000
0000079779977000
0000077997700000
0000999776a00000
0000777aaaaa0000
000070aaaaa00000
0000000aaa000000
0000009997700000
00000957777a0000
0000995597700000
0000995955500000
0000999555000000
00000b99999b0000
00000b90009b0000
000000b000b00000
# frame 4: player avatar walking 3, side
0000000977000000
0000007797700000
0000079779977000
0000077997700000
0000999776a00000
0000777aaaaa0000
000070aaaaa00000
0000000aaa000000
0000009997700000
0000097775500000
0000997795500000
0000995a55500000
0000999555000000
0000000999000000
00000b99099b0000
000000bb0bb00000
# frame 5: player avatar walking 7, side
0000000977000000
0000007797700000
0000079779977000
0000077997700000
0000999776a00000
0000777aaaaa0000
000070aaaaa00000
0000000aaa000000
0000009997700000
0000077795500000
0000a77795500000
00009959a5500000
0000999555000000
00000b99999b0000
00000b90009b0000
000000b000b00000
```

These 6 sprite frames are enough to have a mouse cursor and a player avatar that can walk from side to side. Frames 1-5 have the avatar facing right, but they each can be flipped horizontally to walk to the left.  

With a [simple BASIC program](example/sprite.bas), we can test both the mouse sprite and do a little animation with the avatar: ![sprite demo GIF](example/sprite.gif)

Notice that the mouse pointer has its point in the upper left corner of the frame. This is because that corner pixel is the actual mouse position. This goes for all sprites, where the position specified will be its upper-left corner, so make sure that there is room below and to the right of the position to display the portion of the sprite you want visible.  We'll see how to do this later when configuring game levels.

### Menu File
The menu file is a key-value configuration text file, just like the main file.  This one defines the appearance and behavior of the menu bar, which occupies the top 8 pixel rows of the screen, as well as the toolbar, which can appear at the bottom of the screen. It is also used to define how text is rendered during the game. These elements are all rendered completely with tiles and using only palette offset 0 to maintain consistency throughout the game. The example menu file and tiles provide the basis for any game, but you can customize them however you want for your own game. The example menu file (**mygame_menu.xci**) is shown below.

```
# Menu bar definition
menu_bg 1 # background color = white
menu_fg 0 # foreground color = black
menu_lc 2H
menu_sp 0
menu_rc 2
menu_div 4
menu_check 134
menu_uncheck 135
menu File
item new
item load
item div
item save
item saveas
item div
item exit
menu Sound
item music
item sfx
menu Help
item controls
item div
item about

controls mygame_help.txt
about mygame_about.txt

# text styles
text1_bg 0 # text style 1 background color = black
text1_fg 1 # text style 1 foreground color = white
text2_bg 0
text2_fg 7 # yellow
text3_bg 0
text3_fg 14 # light blue

# Toolbar definition
tb_height 4
tb_width 32
tool inventory
tiles 5H 6 6 9 7 20 20H 8H 7 21 21H 8H 10 11 11 12H
tool walk
tiles 9H 6 6 9 8 13 14 8H 8 15 16 8H 12 11 11 12H
tool run
tiles 9H 6 6 9 8 17 14 8H 8 18 19 8H 12 11 11 12H
tool look
tiles 9H 6 6 9 8 22 22H 8H 8 22V 22HV 8H 12 11 11 12H
tool use
tiles 9H 6 6 9 8 23 24 8H 8 25 26 8H 12 11 11 12H
tool talk
tiles 9H 6 6 9 8 27 28 8H 8 29 30 8H 12 11 11 12H
tool strike
tiles 9H 6 6 9 8 31 127 8H 8 128 129 8H 12 11 11 12H
tool pin
tiles 9H 6 6 5 8 130 130H 7H 8 131 131H 7H 12 11 11 10H # pin out
tiles 9H 6 6 5 8 132 132H 7H 8 133 133H 7H 12 11 11 10H # pin in

inventory mygame_inv.xci
walk 15
run 16
look 17
use 18
talk 19
strike 20
```

When the build utility loads this file (as it was referenced from the main file), it will add data to the main binary file (**MAIN.BIN**) to contain all of this configuration information, with the exception of the text color settings, which result in palette modifications.  The different key specifications will explain how all of the values are used.

What this file gets you, with the complete example tile set (built from **mygame_tiles.hex**), is a menu and toolbar that look like this: ![menu screen](example/menu.png)

So how does XCI take the menu file and make that screen? Let's go through each of the required keys for it.  Just like with the main file, all of these keys need to be present, but after that we'll go through the optional keys that can be in there, whcih are also in the example. Any keys that aren't expected are ignored, just as if they were comments. If any of the values are invalid, the build will fail.

#### Menu File: Required Keys
* **menu_lc** - Tile used for left corner of menu bar.  Tile values consist of the index (in decimal) followed by an optional set of letters. If there are no letters after the number, then the tile is displayed normally. If it is followed by an ```H```, it is flipped horizontally. If it is followed by a ```V```, it is flipped vertically. If it is followed by ```HV```, it is flipped both horizontally and vertically. In the example, it has a value of ```2H```, which means that rounded corner tile we saw before will be used, flipped horizontally.
* **menu_sp** - Tile used for empty space of menu bar. In the example, the plain white square tile (```0```) is specified.
* **menu_rc** - Tile used for right corner of menu bar. In the example, the rounded corner is used again, without any flipping (```2```).
* **menu** - This specifies the name of a menu, which will be rendered using the value's ASCII text. The menu file needs to have at least one menu defined. The menus will be rendered in the order they appear in the menu file, from left to right. The menu will contain all the items specified until the next **menu** key or the end of the file. In the example, the menus defined are ```File```, ```Sound```, and ```Help```. As you can see in the image, the menu bar starts with the left corner tile, followed by the first menu title, then two space tiles, the second menu tile, two more space tile, the last menu tile, enough spacees to fill through the 39th tile space, and finally the right corner tile at the 40th tile space, which is the extreme right end of the visible tiles. Note that the tile map is actually 64 tiles wide in VRAM, but only the first 40 columns are ever visible. When a menu is clicked, it will appear underneath the menu bar. Each item will be preceded by a space tile (unless it's a divider item), followed by the ASCII label for the item, and finally enough space tiles to fill out the menu. The menu width is determined by the longest label among its items, being its width plus 2, to accomodate space tiles on either side of the label. In the example, as seen in the above image, the ```File``` menu is shown, which has ```Load Game...``` as its widest item label, making the total width of the menu 14 tiles.
* **item** - This specifies an item to include is a menu. The items specified in this file will be placed in the last specified menu in order from top to bottom. The values available for items must come from one of the identifiers supported by XCI, but a game only needs to support a subset of these, however it must have at least one non-divider item per menu. The following identifiers are supported:
 * **new** - Rendered as "New Game". This is will start a new game with no progress at zone 0, level 0. If a game is in progress, the player will be prompted to save their game.
 * **load** - Rendered as "Load Game...". This will prompt the player with a list of available saved games to load. The saved game will resume at the last visited level with all progress attained at the time it was saved.
 * **save** - Rendered as "Save Game". This will overwrite th current saved game file. If the current session started from a new game and was never saved before, the player will be prompted for a new filename.
 * **saveas** - Rendered as "Save As...". This will prompt the player for a new filename to save the game. This gives the player the ability to maintain multiple restore points in case they are unsure about their most recent progress.
 * **exit** - Rendered as "Exit".  Will prompt the player with the option to save the game before exitting. This will ultimately trigger a soft reset to bring the player back to the BASIC start screen. It is highly recommended that the a menu contains this item.
 * **music** - Rendered as "Music" preceded by a space for a checkmark. By default, music is turned on, and the checkmark will be displayed. Selecting the item will toggle the checkmark. The state of this item will be stored in the saved game file so that when the game is reloaded the state will be restored to the player's preference. If this item is included in the meanu file, the **menu_check** key needs to be included.
 * **sfx** - Rendered as "Sound Effects" preceded by a space for a checkmark. Toggles the enabling of sound effects, which is also maintained in saved games. It also requires the **menu_check** key.
 * **controls** - Rendered as "Controls". Blacks out the level bitmap and displays the controls guide. This requires the **controls** key to be defined, which will specify the source file for the guide.
 * **about** - Rendered as "About". Blacks out the level bitmap and displays information about the game. This requires the **about** key to be defined, which will specify the source file for the about screen.
 * **div** - Rendered as the divider tile for the width of the menu. Generally is placed between other items to provide visual grouping of similar items. Requires the **menu_div** key to define which tile to use.
* **tb_height** - Height of the toolbar, in tiles. Must be between 1 and 4.
* **tb_width** - Width of the toolbar, in tiles. Must be at least as many tiles as there are tools specified, but no more than 40.
* **tool** - Tool to include on the toolbar. At least one tool must be included. Value must be one of the identifiers of a supported XCI tool. The following tools are supported:
 * **inventory** - Replaces the toolbar with the inventory bar. Requires the **inventory** key to specify the inventory configuration file. When an item is selected from the inventory, the mouse cursor will change to a frame specified in the inventory file and the inventory bar will disappear. Then the player can attempt to use the item on a location within the level by clicking the mouse over the location. Each of these values (except for **inventory** and **pin**) has an identically named optional key for specifying the sprite frame that the mouse cursor will change to. If the corresponding key is not specified, then the mouse will use the default cursor frame when that tool is selected.
 * **walk** - Lets the player select a location for their avatar to attempt to walk to.
 * **run** - Lets the player select a location for their avatar to attempt to run to.
 * **look** - Lets the player select a location to look at and get some information.
 * **use** - Lets the player select a location to attempt to use "bare-handed" (without an inventory item). Generally useful for things like opening doors and picking up new items.
 * **talk** - Lets the player select a location (presumably occupied by a character or listening device) to talk to.
 * **strike** - Lets the player select a location (presumable occupied by an enemy or something that just needs punching) to strike with its hand or whatever weapon is available.
 * **pin** - Lets the player toggle whether the toolbar is pinned in place. By default, when the toolbar first appears (by moving the mouse cursor to the bottom of the screen), the pin is "out", allowing the toolbar to disappear when the mouse cursor leaves it. If the pin is toggled to "in", the toolbar will stay visible until the pin is "pulled out" again. The first **tiles** key after this defines the appearance of the pin being out. If a second **tiles** is in the menu file before the next **tool** key or the end of file, that will define the appearance of the pin being in, otherwise the pin tool will never change appearance from its "out" definition, but it will still work and change state without visual feedback.
* **tiles** - Tiles used for the preceding tool's toolbar button.  Unlike other tile keys described before, this one takes an ordered set of tile indexes (potentially with H and/or V appended for flipping) to define the button area.  Toolbar buttons may have variable widths, but the height is fixed at the value of **tb_height**. In the example menu file, the height is set to 4, so the tiles must be laid out in multiples of 4. So, if 4 tiles are specified, the button is 1 tile wide. In the example, each button specifies 16 tiles, so they are each 4 tiles wide.  The tiles are in left-down order, so that the first 4 are the top row, then the next 3 rows to the bottom.  The total number of tiles for all buttons should be **tb_height** x **tb_width**. In the example, this means that there are 4x32, or 128 tiles across all 8 buttons. Note again that the pin can have two different buttons, so only one of them counts in the total, but both tile sets need to be the same size.

As described for some key-value combinations, some optional keys become required, but they are still specified in the next subsection of this document.

#### Menu File: Optional Keys
* **menu_bg** - Menu background color, based on palette offset 0. By default this is set to 1, which is white in the default X16 palette. This will affect palette offset 11, which will be a copy of palette offset 0, but with color 6 replaced with the color from palette offset 0 specified by this value. So, without this key and using the default X16 palette, palette offset 11 will have color 6 set to white.
* **menu_fg** - Menu foreground color, based on palette offset 0. By default this is set to 0, which is black in the default X16 palette. This will replace color 1 in pallete offset 11 with the color from palette offset 0 specified by this value. So, without this key and using the default X16 palette, palette offset 11 will have color 1 set to black. As seen in the example menu file, the default values were used explicitly for all optional keys, and so the image above shows that the menu has black-on-white letters.
* **menu_div** - Tile to use for menu dividers.  Only required if any **div** items exist in any menu. Specified with the decimal tile index number followed by H and/or V if the tile needs to be flipped. This tile, however it is oriented, will need to be horizontally adjacent to itself, so it should be able to form something like a horizontal line.
* **menu_check** - Tile to use to indicate when a toggle menu item (e.g. **music**) is enabled. Only required if any toggle items exist in any menu. It will be placed to the left of the menu item's level.
* **menu_uncheck** - Tile to use to indicatge when a toggle menu item is disabled. If not specified, the menu space (**menu_sp**) tile will be used.
* **controls** - Filename of the Controls layout file. Only required if any **controls** items exist in any menu. See the [Controls File](#controls-file) section for a specification of its contents.
* **about** - Filename of the About layout file. Only required if any **about** items exist in any menu. See the [About File](#about-file) section for a specification of its contents.
* **text1_bg** - Background color of text style 1, based on palette offset 0. By default it is set to 0, which is black in the default X16 palette. This is used for text that appears in the text field, which can be specified to use text style 0 (same as menu), 1, 2 or 3. Text style 1 is defined by palette offset 12, which is a copy of palette offset 0, but the specified color will replace color 6. So, without this key and using the default X16 palette, palette offset 12 will have color 6 set to black.
* **text1_fg** - Foreground color of text style 1, based on palette offset 0. By default it is set to 1, which is white in the default X16 palette. This will replace color 1 in palette offset 12. So, without this key and using the default X16 palette, palette offset 12 will leave color 1 set to white.
* **text2_bg** - Background color of text style 2, based on palette offset 0. By default it is set to 0, which is black in the default X16 palette. Text style 2 is defined by palette offset 13, which is a copy of palette offset 0, but the specified color will replace color 6. So, without this key and using the default X16 palette, palette offset 13 will have color 6 set to black.
* **text2_fg** - Foreground color of text style 2, based on palette offset 0. By default it is set to 7, which is yellow in the default X16 palette. This will replace color 1 in palette offset 13. So, without this key and using the default X16 palette, palette offset 13 will replace color 1 with yellow.
* **text3_bg** - Background color of text style 3, based on palette offset 0. By default it is set to 0, which is black in the default X16 palette. Text style 3 is defined by palette offset 14, which is a copy of palette offset 0, but the specified color will replace color 6. So, without this key and using the default X16 palette, palette offset 14 will have color 6 set to black.
* **text3_fg** - Foreground color of text style 3, based on palette offset 0. By default it is set to 14, which is light blue in the default X16 palette. This will replace color 1 in palette offset 14. So, without this key and using the default X16 palette, palette offset 14 will replace color 1 with light blue.
* **inventory** - Filename of the inventory configuration file.  Only required if any **inventory** tools exist in the toolbar.  See the [Inventory File](#inventory-file) section for a specification of its contents.
* **walk** - Index for the walk mouse cursor sprite frame. If not specified, the default cursor will be used.
* **run** - Index for the run mouse cursor sprite frame. If not specified, the default cursor will be used.
* **look** - Index for the look mouse cursor sprite frame. If not specified, the default cursor will be used.
* **use** - Index for the walk mouse cursor sprite frame. If not specified, the default cursor will be used.
* **talk** - Index for the walk mouse cursor sprite frame. If not specified, the default cursor will be used.
* **strike** - Index for the walk mouse cursor sprite frame. If not specified, the default cursor will be used.

### Help Files
Help files are simple tile layout files that expect most tiles to be ASCII characters. To do this, rather than using hex files, they are regular text files with some basic markup. Like will all other file, hash symbols are used for comments, unless preceded by a backslash (```\#```), which will specify an actual hash character tile to be rendered. Double backslashes (```\\```) are used to specify backslash tiles. Non-ASCII tiles are specified by a backslash followed by the tile index and optionally H and/or V for flipping. For example, an upside-down X16 butterfly would be ```\3V```. ASCII tiles can also be flipped, but they must be treated like other tiles and use their tile index (which is the same as their decimal ASCII code) after a backslash. For example, a backwards ```E``` would be ```\45H```. If an ```H``` or ```V``` tile needs to immediately follow an escaped tile index, it must be preceded with a backslash (e.g. ```\3\H``` is a butterfly followed by an ```H```, rather than flipped horizontally). ASCII tiles will use the menu colors, a.k.a. text style 0, which is black-on-white by default. All other tiles will use palette offset 0. All whitespace characters will be rendered as space character tiles. Each line can specify no more than 40 tiles.  There can be no more than 25 lines. When rendered, the tiles will be centered in the level area (rows 1-25). Rows shorter than the longest row will be filled out with space tiles. Clicking on the level area will remove the help screen and return the user to the game.

The following sections show examples of how help files can be formatted.

#### Controls File
The controls file is a help file whose filename is specified by the **controls** key in the menu file. It is rendered when the player selects the "Controls" menu item. The example controls file (**mygame_help.txt**) is written as follows.

```
# This is a comment.
\2H                                      \2
 File: Start, load, save & exit game
 Sound: Toggle music and sound effects

 Mouse down to bottom to show toolbar

 \20\20H Show            \23\24 Use or
 \21\21H Inventory       \25\26 Take

 \13\14 Walk to         \27\28 Talk to
 \15\16 Location        \29\30 Somebody

 \17\14 Run to          \31\127 Punch
 \18\19 Location        \128\129 Something!

 \22\22H Look at         \130\130H Pin/Unpin
 \22V\22HV Something       \131\131H Toolbar

\2HV                   click to close Help\2V
```

When rendered, it will appear on screen like this: ![controls help](example/help.png)

Note that the toolbar is pinned and no menus are visible to show how the tile layout will be centered in the level area.

#### About File
The about file is a help file whoe=se filename is specified by the **about** key in the menu file.  It is rendered when the player selects the "About" menu item. The example controls file (**mygame_about.txt**) is written as follows.

```
\2H                                   \2
 My Game: An Exemplary XCI Adventure
 Copyleft 2020 by John Doe
 Version 0.0
\2HV               click to close About\2V
```

When rendered, it will appear on screen like this: ![about box](example/about.png)

Note that the toolbar is pinned and no menus are visible to show how the tile layout will be centered in the level area.

### Title Screen File
(TODO)

### Inventory File
(TODO)

#### Raw Image Files
(TODO)

### Zone Files
(TODO)

#### Level Files
(TODO)

#### VGM Files
(TODO)

#### Sound Effects Files
(TODO)

## Building XCI Toolchain from Source
(TODO)

## Building XCI Game Binaries
(TODO)

## Deploying XCI Game
(TODO)

## Licensing
(TODO)

## Notes
